/**
 * Project Scaffolding Service
 * 
 * Creates complete project directory structure
 * Generates all necessary files from templates
 * Sets up dependencies, git, and documentation
 */

import VNCTemplates, { TemplateParams } from '../templates/vnc-templates';
import { mcpCodeGenerator, GeneratedFile } from './mcp-code-generator';

export interface ProjectConfig {
  name: string;
  description: string;
  type: 'fullstack' | 'frontend' | 'backend' | 'library' | 'api';
  features: ('navigation' | 'ui' | 'database' | 'realtime' | '3d-viz' | 'multi-agent')[];
  deploymentTargets: ('docker' | 'kubernetes' | 'vercel' | 'aws' | 'gcp')[];
  author?: string;
  license?: 'MIT' | 'Apache-2.0' | 'GPL-3.0';
}

export interface ProjectStructure {
  root: string;
  files: GeneratedFile[];
  directories: string[];
  packageConfig: any;
  gitInitialized: boolean;
  readmeContent: string;
}

class ProjectScaffolder {
  /**
   * Create complete project from configuration
   */
  async createProject(config: ProjectConfig): Promise<ProjectStructure> {
    console.log(`üöÄ Scaffolding project: ${config.name}`);
    
    const files: GeneratedFile[] = [];
    const directories: string[] = [];
    
    // Create directory structure
    directories.push(...this.createDirectoryStructure(config));
    
    // Generate core files based on type
    files.push(...await this.generateCoreFiles(config));
    
    // Generate feature-specific files
    for (const feature of config.features) {
      files.push(...await this.generateFeatureFiles(feature, config));
    }
    
    // Generate configuration files
    files.push(...this.generateConfigFiles(config));
    
    // Generate deployment configurations
    if (config.deploymentTargets.length > 0) {
      files.push(...await this.generateDeploymentConfigs(config));
    }
    
    // Generate documentation
    const readmeContent = this.generateREADME(config, files);
    files.push({
      path: 'README.md',
      content: readmeContent,
      language: 'json',
      description: 'Project documentation'
    });
    
    // Generate package configuration
    const packageConfig = this.generatePackageConfig(config);
    files.push({
      path: 'package.json',
      content: JSON.stringify(packageConfig, null, 2),
      language: 'json',
      description: 'Package configuration'
    });
    
    // Generate .gitignore
    files.push({
      path: '.gitignore',
      content: this.generateGitignore(),
      language: 'json',
      description: 'Git ignore file'
    });
    
    console.log(`‚úÖ Generated ${files.length} files across ${directories.length} directories`);
    
    return {
      root: config.name,
      files,
      directories,
      packageConfig,
      gitInitialized: true,
      readmeContent,
    };
  }

  /**
   * Create directory structure based on project type
   */
  private createDirectoryStructure(config: ProjectConfig): string[] {
    const dirs: string[] = [];
    
    // Base directories
    dirs.push('src');
    dirs.push('tests');
    dirs.push('docs');
    
    // Type-specific directories
    if (config.type === 'fullstack' || config.type === 'frontend') {
      dirs.push('src/ui');
      dirs.push('src/ui/components');
      dirs.push('src/ui/visualizers');
      dirs.push('public');
    }
    
    if (config.type === 'fullstack' || config.type === 'backend' || config.type === 'api') {
      dirs.push('src/api');
      dirs.push('src/api/routes');
      dirs.push('src/api/middleware');
    }
    
    if (config.features.includes('navigation')) {
      dirs.push('src/core');
      dirs.push('src/core/navigation');
      dirs.push('src/core/pathfinding');
    }
    
    if (config.features.includes('database')) {
      dirs.push('src/models');
      dirs.push('src/repositories');
      dirs.push('migrations');
    }
    
    if (config.deploymentTargets.length > 0) {
      dirs.push('deployment');
      dirs.push('k8s');
      dirs.push('.github');
      dirs.push('.github/workflows');
    }
    
    return dirs;
  }

  /**
   * Generate core project files
   */
  private async generateCoreFiles(config: ProjectConfig): Promise<GeneratedFile[]> {
    const files: GeneratedFile[] = [];
    
    // Main entry point
    files.push({
      path: 'src/main.vnc',
      language: 'vnc',
      description: 'Main application entry point',
      content: `// ${config.name} - Main Entry Point
// Generated by NAVŒõ Studio IDE

import { App‚ãã } from './app.vnc'
${config.features.includes('navigation') ? "import { NavigationSystem‚ãã } from './core/navigation.vnc'" : ''}
${config.features.includes('database') ? "import { Database‚ãã } from './database.vnc'" : ''}

fn main‚ãã() -> Result‚ãã<()> {
  console.log‚ãã("üöÄ Starting ${config.name}...")
  
  ${config.features.includes('database') ? '// Initialize database\n  let db = Database‚ãã::connect(env‚ãã("DATABASE_URL"))\n' : ''}
  ${config.features.includes('navigation') ? '// Initialize navigation system\n  let nav_system = NavigationSystem‚ãã::new()\n' : ''}
  
  // Start application
  let app = App‚ãã::new()
  app.start‚ãã()
  
  console.log‚ãã("‚úÖ ${config.name} running successfully")
  Ok(())
}
`
    });
    
    return files;
  }

  /**
   * Generate feature-specific files
   */
  private async generateFeatureFiles(feature: string, config: ProjectConfig): Promise<GeneratedFile[]> {
    const files: GeneratedFile[] = [];
    
    switch (feature) {
      case 'navigation':
        files.push({
          path: 'src/core/navigation.vnc',
          language: 'vnc',
          description: 'Navigation system implementation',
          content: VNCTemplates.navigationAlgorithm({ projectName: config.name })
        });
        break;
      
      case 'ui':
        files.push({
          path: 'src/ui/App.vnc',
          language: 'vnc',
          description: 'Main UI application',
          content: VNCTemplates.uiComponent({ entityName: 'App' })
        });
        break;
      
      case 'database':
        files.push({
          path: 'src/models/entities.vnc',
          language: 'vnc',
          description: 'Database entities',
          content: VNCTemplates.databaseModel({ 
            entityName: 'Mission',
            fields: [
              { name: 'id', type: 'UUID‚ãã' },
              { name: 'name', type: 'String' },
              { name: 'status', type: 'String' }
            ]
          })
        });
        break;
      
      case '3d-viz':
        files.push({
          path: 'src/ui/visualizers/Navigation3D.vnc',
          language: 'vnc',
          description: '3D navigation visualization',
          content: this.generate3DVisualizerTemplate(config.name)
        });
        break;
    }
    
    return files;
  }

  /**
   * Generate configuration files
   */
  private generateConfigFiles(config: ProjectConfig): GeneratedFile[] {
    const files: GeneratedFile[] = [];
    
    // .env.example
    files.push({
      path: '.env.example',
      content: `# ${config.name} Environment Configuration

# Database
DATABASE_URL=postgresql://postgres:password@localhost:5432/${config.name}

# Redis
REDIS_URL=redis://localhost:6379

# Server
PORT=8080
HOST=0.0.0.0

# Logging
LOG_LEVEL=info

# VNC Configuration
VNC_OPTIMIZATION_LEVEL=3
VNC_ENABLE_7D=true
`,
      language: 'json',
      description: 'Environment variables template'
    });
    
    return files;
  }

  /**
   * Generate deployment configurations
   */
  private async generateDeploymentConfigs(config: ProjectConfig): Promise<GeneratedFile[]> {
    const files: GeneratedFile[] = [];
    
    const deployment = VNCTemplates.deployment({ projectName: config.name });
    
    if (config.deploymentTargets.includes('docker')) {
      files.push({
        path: 'Dockerfile',
        content: deployment.dockerfile,
        language: 'dockerfile',
        description: 'Docker container configuration'
      });
      
      files.push({
        path: 'docker-compose.yaml',
        content: deployment.dockerCompose,
        language: 'yaml',
        description: 'Docker Compose orchestration'
      });
    }
    
    if (config.deploymentTargets.includes('kubernetes')) {
      files.push({
        path: 'k8s/deployment.yaml',
        content: deployment.kubernetes,
        language: 'yaml',
        description: 'Kubernetes deployment manifest'
      });
    }
    
    if (config.deploymentTargets.includes('aws') || config.deploymentTargets.includes('gcp')) {
      files.push({
        path: '.github/workflows/deploy.yaml',
        content: deployment.cicd,
        language: 'yaml',
        description: 'GitHub Actions CI/CD pipeline'
      });
    }
    
    return files;
  }

  /**
   * Generate package.json
   */
  private generatePackageConfig(config: ProjectConfig): any {
    return {
      name: config.name,
      version: '1.0.0',
      description: config.description,
      main: 'dist/main.js',
      scripts: {
        dev: 'vnc-compiler watch --target=typescript && vite',
        build: 'vnc-compiler compile --target=rust --optimize=3 && cargo build --release',
        test: 'cargo test',
        deploy: 'docker-compose up --build'
      },
      dependencies: this.getDefaultDependencies(config),
      devDependencies: {
        'vite': '^5.0.0',
        'typescript': '^5.0.0',
        '@types/node': '^20.0.0'
      },
      author: config.author || 'NAVŒõ Studio IDE',
      license: config.license || 'MIT'
    };
  }

  private getDefaultDependencies(config: ProjectConfig): Record<string, string> {
    const deps: Record<string, string> = {};
    
    if (config.features.includes('ui')) {
      deps['react'] = '^18.2.0';
      deps['react-dom'] = '^18.2.0';
    }
    
    if (config.features.includes('3d-viz')) {
      deps['three'] = '^0.160.0';
    }
    
    if (config.features.includes('realtime')) {
      deps['ws'] = '^8.14.0';
    }
    
    return deps;
  }

  /**
   * Generate comprehensive README
   */
  private generateREADME(config: ProjectConfig, files: GeneratedFile[]): string {
    return `# ${config.name}

${config.description}

**Generated by:** NAVŒõ Studio IDE  
**Uses:** Van Laarhoven Navigation Calculus (VNC)  
**Type:** ${config.type}  

## üöÄ Quick Start

\`\`\`bash
# Install dependencies
npm install

# Compile VNC to Rust
vnc-compiler compile --target=rust

# Run in development
npm run dev

# Build for production
npm run build

# Run with Docker
docker-compose up
\`\`\`

## üìÅ Project Structure

\`\`\`
${config.name}/
${files.map(f => '  ' + f.path).join('\n')}
\`\`\`

## ‚ú® Features

${config.features.map(f => `- ${f.replace('-', ' ').toUpperCase()}`).join('\n')}

## üßÆ Van Laarhoven Navigation Calculus

This project uses VNC for advanced navigation in 7D spacetime:

- **t**: Time dimension
- **x, y, z**: Spatial coordinates  
- **G**: Goal-directedness (0-1)
- **I**: Intention weight (0-1)
- **C**: Consciousness/awareness (0-1)

The **‚ãã** operator represents 7-dimensional navigation operations.

## üìö Documentation

See \`docs/\` folder for detailed documentation:
- Architecture overview
- API reference
- Deployment guide
- Mathematics explanation

## üõ†Ô∏è Development

\`\`\`bash
# Run tests
cargo test

# Watch mode
npm run dev

# Lint VNC code
vnc-lint src/**/*.vnc
\`\`\`

## üöÄ Deployment

### Docker
\`\`\`bash
docker build -t ${config.name} .
docker run -p 8080:8080 ${config.name}
\`\`\`

### Kubernetes
\`\`\`bash
kubectl apply -f k8s/
\`\`\`

## üìù License

${config.license || 'MIT OR Apache-2.0'}

---

**Built with** ü¶Ä Rust + ‚ãã VNC  
**Powered by** NAVŒõ Studio IDE
`;
  }

  /**
   * Generate .gitignore
   */
  private generateGitignore(): string {
    return `# VNC Compiler Output
/target/
*.vnc.rs
*.vnc.py
*.vnc.wasm

# Dependencies
/node_modules/
/.pnp
.pnp.js

# Testing
/coverage/
*.log

# Production
/dist/
/build/

# Environment
.env
.env.local
.env.production

# Editor
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Docker
.dockerignore

# Rust
Cargo.lock
`;
  }

  /**
   * Add component to existing project
   */
  async addComponent(path: string, template: string, params: TemplateParams): Promise<GeneratedFile> {
    const content = VNCTemplates.getTemplate(template, params);
    
    return {
      path,
      content,
      language: 'vnc',
      description: `Generated ${template} component`
    };
  }

  /**
   * Generate 3D visualizer template
   */
  private generate3DVisualizerTemplate(projectName: string): string {
    return `// 3D Navigation Visualizer using Three.js integration
// Real-time path rendering with energy gradients

import { Scene‚ãã, Camera‚ãã, Renderer‚ãã } from '@navlambda/three'

class NavigationVisualizer3D‚ãã {
  scene: Scene‚ãã
  camera: Camera‚ãã
  renderer: Renderer‚ãã
  paths: Array<Path‚ãã>
  
  fn init‚ãã() {
    // Setup Three.js scene
    this.scene = Scene‚ãã::new()
    this.camera = Camera‚ãã::perspective(75, window.aspect_ratio(), 0.1, 1000)
    this.renderer = Renderer‚ãã::webgl({ antialias: true })
    
    // Add lighting
    this.scene.add‚ãã(AmbientLight‚ãã(0x404040))
    this.scene.add‚ãã(DirectionalLight‚ãã(0xffffff, 0.8))
    
    // Add grid
    this.scene.add‚ãã(GridHelper‚ãã(100, 100))
  }
  
  fn render_path‚ãã(path: Path‚ãã) {
    // Create path geometry
    let geometry = PathGeometry‚ãã::from_waypoints(path.waypoints)
    
    // Energy-based color gradient
    let material = GradientMaterial‚ãã {
      colors: path.waypoints.map‚ãã(|wp| {
        let energy = wp.energy
        return color_from_energy‚ãã(energy) // Green (low) to Red (high)
      })
    }
    
    let line = Line‚ãã::new(geometry, material)
    this.scene.add‚ãã(line)
  }
  
  fn animate‚ãã() {
    // Animation loop at 60 FPS
    request_animation_frame‚ãã(|| {
      this.update‚ãã()
      this.renderer.render‚ãã(this.scene, this.camera)
      this.animate‚ãã()
    })
  }
  
  fn update‚ãã() {
    // Update camera, animations, etc.
    this.camera.update‚ãã()
  }
}

// Helper: Convert energy value to color
fn color_from_energy‚ãã(energy: Float) -> Color‚ãã {
  let normalized = clamp‚ãã(energy / 100.0, 0.0, 1.0)
  let r = normalized
  let g = 1.0 - normalized
  let b = 0.0
  
  return Color‚ãã::rgb(r, g, b)
}

export { NavigationVisualizer3D‚ãã }
`;
  }
}

// Export singleton instance
export const projectScaffolder = new ProjectScaffolder();
export default projectScaffolder;

