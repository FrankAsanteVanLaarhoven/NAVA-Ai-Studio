{"instruction": "Write NAVA code that plans a path from (1,1) to (6,6) on the Euclidean plane avoiding a circular obstacle at (3,3) with radius 1.5.", "input": "", "output": "let M = euclidean_plane()\n\nlet start = [1.0, 1.0]\nlet goal  = [6.0, 6.0]\n\n// Circular obstacle at (3,3) with radius 1.5\nlet obstacle = disc(center: [3.0, 3.0], radius: 1.5)\n\nlet field = navigation_field(\n  manifold: M,\n  start: start,\n  goal: goal,\n  obstacles: [obstacle],\n  cost: geodesic_cost()\n)\n\nlet path = compute_optimal_path(field)\nvisualize(path, field)\n"}
{"instruction": "Write NAVA code for a smooth path on R^2 from (0,0) to (8,4) with low curvature using a custom cost function.", "input": "", "output": "let M = euclidean_plane()\n\nlet start = [0.0, 0.0]\nlet goal  = [8.0, 4.0]\n\n// Cost function that heavily penalises curvature\nlet smooth_cost = cost_function(\n  length_weight: 1.0,\n  curvature_weight: 3.0,\n  jerk_weight: 1.0\n)\n\nlet field = navigation_field(\n  manifold: M,\n  start: start,\n  goal: goal,\n  obstacles: [],\n  cost: smooth_cost\n)\n\nlet path = compute_optimal_path(field)\nvisualize(path, field)\n"}
{"instruction": "Explain this NAVA code in GCSE-level language.", "input": "let M = euclidean_plane()\nlet start = [0.0, 0.0]\nlet goal  = [4.0, 4.0]\nlet obstacle = disc(center: [2.0, 2.0], radius: 1.0)\nlet field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [obstacle])\nlet path = compute_optimal_path(field)\n", "output": "This code finds a path from point (0,0) to point (4,4) on a flat surface.\n\nThere's a circular obstacle in the middle at (2,2) with radius 1, which is like a round wall.\n\nThe navigation field creates an invisible guide that:\n- Points towards the goal (4,4)\n- Pushes away from the obstacle\n\nThe optimal path is a smooth curve that goes from start to goal while avoiding the obstacle. It's like finding the best route around a roundabout."}
{"instruction": "Explain this code to an A-level student, focusing on what the cost function does.", "input": "let M = euclidean_plane()\nlet start = [0.0, 0.0]\nlet goal  = [5.0, 5.0]\nlet cost = cost_function(length_weight: 1.0, curvature_weight: 2.0)\nlet field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: cost)\nlet path = compute_optimal_path(field)\n", "output": "This code plans a path on the 2D plane from (0,0) to (5,5).\n\nThe cost function defines what makes a path \"good\":\n- `length_weight: 1.0` means we want a reasonably short path\n- `curvature_weight: 2.0` means we want to avoid sharp turns (high curvature is penalised twice as much as extra length)\n\nSo the optimiser will choose a path that balances being short with being smooth. If there are two paths of similar length, it will prefer the one with fewer sharp turns."}
{"instruction": "Explain this NAVA code to a PhD student, focusing on the manifold and geodesic structure.", "input": "let M = se2()\nlet start = [0.0, 0.0, 0.0]\nlet goal = [5.0, 5.0, 1.570796]\nlet field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\nlet path = compute_optimal_path(field)\n", "output": "This code formulates a navigation problem on SE(2), the Special Euclidean group in 2D.\n\n- SE(2) is the configuration space of a planar rigid body: positions (x,y) plus orientation θ.\n- The start pose is (0,0,0) and goal is (5,5,π/2), so we need to reach position (5,5) with orientation π/2.\n- `geodesic_cost()` minimises the distance on SE(2) under the natural left-invariant metric, which combines translational and rotational distances.\n- The geodesic on SE(2) is not simply a straight line in (x,y,θ) space; it accounts for the coupling between translation and rotation.\n- `compute_optimal_path` finds the geodesic connecting start to goal, which is the natural \"shortest path\" on this curved configuration space."}

