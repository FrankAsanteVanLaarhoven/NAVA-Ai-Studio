{"instruction": "Write NAVA code that plans a smooth path from (0,0) to (5,5) on the Euclidean plane with no obstacles.", "input": "", "output": "let M = euclidean_plane()\n\nlet start = [0.0, 0.0]\nlet goal  = [5.0, 5.0]\n\n// Simple navigation field on R^2 from start to goal\nlet field = navigation_field(\n  manifold: M,\n  start: start,\n  goal: goal,\n  obstacles: [],\n  cost: geodesic_cost()\n)\n\nlet path = compute_optimal_path(field)\n\nvisualize(path, field)\n"}
{"instruction": "Write NAVA code to go from (0,0) to (5,5) on R^2 while avoiding a circular obstacle at (2,2) of radius 1.", "input": "", "output": "let M = euclidean_plane()\n\nlet start = [0.0, 0.0]\nlet goal  = [5.0, 5.0]\n\n// Circular obstacle at (2,2) with radius 1\nlet obstacle = disc(center: [2.0, 2.0], radius: 1.0)\n\nlet field = navigation_field(\n  manifold: M,\n  start: start,\n  goal: goal,\n  obstacles: [obstacle],\n  cost: geodesic_cost()\n)\n\nlet path = compute_optimal_path(field)\n\nvisualize(path, field)\n"}
{"instruction": "I am an A-level student. Write NAVA code that defines a planar navigation problem with two circular obstacles and explain each step with comments.", "input": "", "output": "let M = euclidean_plane()\n\n// Start and goal positions in the plane\nlet start = [0.0, 0.0]\nlet goal  = [6.0, 4.0]\n\n// Two circular obstacles\nlet obstacle1 = disc(center: [2.0, 1.0], radius: 0.8)\nlet obstacle2 = disc(center: [4.0, 3.0], radius: 1.0)\n\n// Build a navigation field that pulls us from start to goal\n// while pushing us away from the obstacles\nlet field = navigation_field(\n  manifold: M,\n  start: start,\n  goal: goal,\n  obstacles: [obstacle1, obstacle2],\n  cost: geodesic_cost()\n)\n\n// Compute a smooth path that follows the field\nlet path = compute_optimal_path(field)\n\n// Show both the field and the path\nvisualize(path, field)\n"}
{"instruction": "Write NAVA code that defines a navigation problem on the unit circle S^1, going from angle 0 to angle pi/2.", "input": "", "output": "let M = circle(radius: 1.0)  // S^1\n\n// Angles in radians on S^1\nlet start_angle = 0.0\nlet goal_angle  = 1.5707963  // pi/2\n\nlet field = navigation_field(\n  manifold: M,\n  start: start_angle,\n  goal: goal_angle,\n  obstacles: [],\n  cost: geodesic_cost()\n)\n\nlet path = compute_optimal_path(field)\n\nvisualize(path, field)\n"}
{"instruction": "Write NAVA code for a path on R^2 from (0,0) to (10,0) that prefers paths with low curvature and low jerk.", "input": "", "output": "let M = euclidean_plane()\n\nlet start = [0.0, 0.0]\nlet goal  = [10.0, 0.0]\n\n// Define a cost that penalises curvature and jerk\nlet smooth_cost = cost_function(\n  length_weight: 1.0,\n  curvature_weight: 2.0,\n  jerk_weight: 2.0\n)\n\nlet field = navigation_field(\n  manifold: M,\n  start: start,\n  goal: goal,\n  obstacles: [],\n  cost: smooth_cost\n)\n\nlet path = compute_optimal_path(field)\nvisualize(path, field)\n"}
{"instruction": "Write NAVA code to navigate a point robot around a rectangular obstacle, and use comments to explain the geometry choices.", "input": "", "output": "let M = euclidean_plane()\n\n// Start at the origin, goal to the top-right\nlet start = [0.0, 0.0]\nlet goal  = [8.0, 6.0]\n\n// Axis-aligned rectangular obstacle\nlet obstacle = rectangle(\n  min_corner: [3.0, 2.0],\n  max_corner: [5.0, 4.0]\n)\n\n// Build navigation field on R^2 with one rectangle obstacle\nlet field = navigation_field(\n  manifold: M,\n  start: start,\n  goal: goal,\n  obstacles: [obstacle],\n  cost: geodesic_cost()\n)\n\n// Compute a path that bends around the rectangle\nlet path = compute_optimal_path(field)\n\n// Visualise path and obstacle for inspection\nvisualize(path, field)\n"}
{"instruction": "Write NAVA code for a 3D navigation problem on R^3 from (0,0,0) to (5,5,5) with a spherical obstacle at (2,2,2) of radius 1.", "input": "", "output": "let M = euclidean_space(dim: 3)  // R^3\n\nlet start = [0.0, 0.0, 0.0]\nlet goal  = [5.0, 5.0, 5.0]\n\n// Spherical obstacle in 3D\nlet obstacle = sphere(center: [2.0, 2.0, 2.0], radius: 1.0)\n\nlet field = navigation_field(\n  manifold: M,\n  start: start,\n  goal: goal,\n  obstacles: [obstacle],\n  cost: geodesic_cost()\n)\n\nlet path = compute_optimal_path(field)\nvisualize(path, field)\n"}
{"instruction": "Write NAVA code for a path planning problem on SE(2) (planar robot with rotation) from pose (0,0,0) to (5,5,pi/4).", "input": "", "output": "let M = se2()  // Special Euclidean group SE(2)\n\n// Pose: (x, y, theta)\nlet start_pose = [0.0, 0.0, 0.0]\nlet goal_pose  = [5.0, 5.0, 0.785398]  // pi/4 radians\n\nlet field = navigation_field(\n  manifold: M,\n  start: start_pose,\n  goal: goal_pose,\n  obstacles: [],\n  cost: geodesic_cost()\n)\n\nlet path = compute_optimal_path(field)\nvisualize(path, field)\n"}
{"instruction": "Write NAVA code for time-optimal path planning from (0,0) to (10,0) on R^2 with a maximum velocity constraint.", "input": "", "output": "let M = euclidean_plane()\n\nlet start = [0.0, 0.0]\nlet goal  = [10.0, 0.0]\n\n// Time-optimal cost function\nlet time_cost = cost_function(\n  type: \"time_optimal\",\n  max_velocity: 2.0\n)\n\nlet field = navigation_field(\n  manifold: M,\n  start: start,\n  goal: goal,\n  obstacles: [],\n  cost: time_cost\n)\n\nlet path = compute_optimal_path(field)\nvisualize(path, field)\n"}
{"instruction": "Write NAVA code for energy-optimal navigation on R^2 from (0,0) to (8,6) with two circular obstacles.", "input": "", "output": "let M = euclidean_plane()\n\nlet start = [0.0, 0.0]\nlet goal  = [8.0, 6.0]\n\nlet obstacle1 = disc(center: [3.0, 2.0], radius: 1.0)\nlet obstacle2 = disc(center: [6.0, 4.0], radius: 1.2)\n\n// Energy-optimal cost\nlet energy_cost = cost_function(\n  type: \"energy_optimal\",\n  energy_weight: 1.0\n)\n\nlet field = navigation_field(\n  manifold: M,\n  start: start,\n  goal: goal,\n  obstacles: [obstacle1, obstacle2],\n  cost: energy_cost\n)\n\nlet path = compute_optimal_path(field)\nvisualize(path, field)\n"}
{"instruction": "Explain this NAVA code in simple GCSE-level language.", "input": "let M = euclidean_plane()\nlet start = [0.0, 0.0]\nlet goal  = [5.0, 5.0]\nlet field = navigation_field(manifold: M, start: start, goal: goal)\nlet path  = compute_optimal_path(field)\nvisualize(path, field)\n", "output": "This code does four main things:\n\n1. It says \"our world is a flat 2D plane\" using `euclidean_plane()`.\n2. It sets a starting point at (0,0) and a goal point at (5,5).\n3. It builds a \"navigation field\" that gently guides a point from start to goal.\n4. It then works out a smooth path that follows this field and draws both the path and the field.\n\nSo in plain terms: it finds and shows a nice path from (0,0) to (5,5) in the plane."}
{"instruction": "Explain what this NAVA code does and emphasise the geometry and obstacles for an A-level student.", "input": "let M = euclidean_plane()\nlet start = [0.0, 0.0]\nlet goal  = [6.0, 4.0]\n\nlet obstacle1 = disc(center: [2.0, 1.0], radius: 0.8)\nlet obstacle2 = disc(center: [4.0, 3.0], radius: 1.0)\n\nlet field = navigation_field(\n  manifold: M,\n  start: start,\n  goal: goal,\n  obstacles: [obstacle1, obstacle2],\n  cost: geodesic_cost()\n)\n\nlet path = compute_optimal_path(field)\nvisualize(path, field)\n", "output": "Geometrically, this code is working on the 2D Euclidean plane.\n\n- It chooses a start point at (0,0) and a goal at (6,4).\n- It then defines two circular obstacles: one centred at (2,1) with radius 0.8, and another at (4,3) with radius 1.0.\n- `navigation_field` builds a vector field on the plane that points towards the goal but also repels the path away from the two discs.\n- `compute_optimal_path` finds a smooth curve from start to goal that follows this vector field while avoiding the discs.\n- Finally, `visualize` plots the path and the field, so you can see how the path bends around the obstacles."}
{"instruction": "Explain this code to a robotics PhD student. Focus on manifolds, cost structure, and what is being optimised.", "input": "let M = euclidean_plane()\nlet start = [0.0, 0.0]\nlet goal  = [10.0, 0.0]\n\nlet smooth_cost = cost_function(\n  length_weight: 1.0,\n  curvature_weight: 2.0,\n  jerk_weight: 2.0\n)\n\nlet field = navigation_field(\n  manifold: M,\n  start: start,\n  goal: goal,\n  obstacles: [],\n  cost: smooth_cost\n)\n\nlet path = compute_optimal_path(field)\n", "output": "The code sets up a navigation problem on the Euclidean plane R^2.\n\n- The state manifold `M` is R^2 with the standard Euclidean metric.\n- The start and goal states are (0,0) and (10,0), so we are effectively planning a path along the x-axis but allowing deviations.\n- The `smooth_cost` function specifies a weighted sum of arc length, curvature, and jerk. This pushes the optimiser towards trajectories that are not just short, but also have low curvature and low jerk.\n- `navigation_field` constructs a potential or vector field whose gradient encodes this cost structure.\n- `compute_optimal_path` then finds a trajectory on M that minimises the integrated cost under that field, subject to the boundary conditions.\n\nIn short, this is an optimal control problem on R^2 with a regularisation on curvature and jerk, expressed in NAVA's navigation field formalism."}
{"instruction": "Explain this NAVA code in GCSE-level language, focusing on what obstacles do.", "input": "let M = euclidean_plane()\nlet start = [0.0, 0.0]\nlet goal  = [5.0, 5.0]\nlet obstacle = disc(center: [2.0, 2.0], radius: 1.0)\nlet field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [obstacle])\nlet path = compute_optimal_path(field)\n", "output": "This code plans a path from (0,0) to (5,5) on a flat plane, but there's a circular obstacle in the way at (2,2) with radius 1.\n\nThe obstacle is like a wall that the path must go around. The navigation field is like an invisible force that:\n- Pulls the path towards the goal (5,5)\n- Pushes the path away from the obstacle\n\nWhen the code computes the optimal path, it finds a smooth route that goes from start to goal while staying away from the obstacle. It's like finding the best way to walk from one point to another while avoiding a puddle."}
{"instruction": "Explain this NAVA code for an A-level student, focusing on the cost function.", "input": "let M = euclidean_plane()\nlet start = [0.0, 0.0]\nlet goal  = [10.0, 0.0]\nlet smooth_cost = cost_function(length_weight: 1.0, curvature_weight: 2.0, jerk_weight: 2.0)\nlet field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: smooth_cost)\nlet path = compute_optimal_path(field)\n", "output": "This code plans a path on the 2D plane from (0,0) to (10,0).\n\nThe key part is the `smooth_cost` function, which defines what makes a \"good\" path:\n- `length_weight: 1.0` means we want the path to be reasonably short\n- `curvature_weight: 2.0` means we really want to avoid sharp turns (high curvature)\n- `jerk_weight: 2.0` means we want smooth acceleration changes (low jerk)\n\nBy giving curvature and jerk higher weights than length, the optimiser will prefer a slightly longer path if it means fewer sharp turns and smoother motion. This is useful for robots that need to move smoothly without sudden direction changes."}
{"instruction": "Explain this NAVA code to a PhD student, focusing on the manifold structure and geodesic computation.", "input": "let M = circle(radius: 1.0)\nlet start_angle = 0.0\nlet goal_angle = 1.5707963\nlet field = navigation_field(manifold: M, start: start_angle, goal: goal_angle, obstacles: [], cost: geodesic_cost())\nlet path = compute_optimal_path(field)\n", "output": "This code formulates a navigation problem on the circle S^1, parameterised by angle.\n\n- The manifold `M` is the unit circle, which is a 1D compact manifold with the standard arc-length metric.\n- Start and goal are specified as angles (0 and Ï€/2 radians).\n- `geodesic_cost()` means we are minimising the arc length along S^1, which for a circle is simply the shorter angular distance between start and goal.\n- `navigation_field` constructs a potential field on S^1 whose gradient points along the geodesic.\n- `compute_optimal_path` finds the geodesic connecting start to goal, which on S^1 is the arc of minimal angular distance.\n\nThis is a simple example of optimal control on a non-Euclidean manifold, where the geodesic is the natural \"straight line\" on the curved space."}
{"instruction": "Write NAVA code for a navigation problem on a sphere S^2 from point (1,0,0) to (0,1,0) on the unit sphere.", "input": "", "output": "let M = sphere(radius: 1.0)  // S^2\n\n// Points on the unit sphere\nlet start = [1.0, 0.0, 0.0]\nlet goal  = [0.0, 1.0, 0.0]\n\nlet field = navigation_field(\n  manifold: M,\n  start: start,\n  goal: goal,\n  obstacles: [],\n  cost: geodesic_cost()\n)\n\nlet path = compute_optimal_path(field)\nvisualize(path, field)\n"}
{"instruction": "Write NAVA code for a path on R^2 from (0,0) to (7,7) with three circular obstacles arranged in a triangle pattern.", "input": "", "output": "let M = euclidean_plane()\n\nlet start = [0.0, 0.0]\nlet goal  = [7.0, 7.0]\n\n// Three obstacles in a triangle\nlet obstacle1 = disc(center: [2.0, 2.0], radius: 0.8)\nlet obstacle2 = disc(center: [4.0, 2.0], radius: 0.8)\nlet obstacle3 = disc(center: [3.0, 4.0], radius: 0.8)\n\nlet field = navigation_field(\n  manifold: M,\n  start: start,\n  goal: goal,\n  obstacles: [obstacle1, obstacle2, obstacle3],\n  cost: geodesic_cost()\n)\n\nlet path = compute_optimal_path(field)\nvisualize(path, field)\n"}
{"instruction": "Write NAVA code for a beginner that creates a simple path from (0,0) to (3,3) with helpful comments explaining each line.", "input": "", "output": "// Create a flat 2D plane for our navigation problem\nlet M = euclidean_plane()\n\n// Set where we start (the origin)\nlet start = [0.0, 0.0]\n\n// Set where we want to go\nlet goal  = [3.0, 3.0]\n\n// Build a navigation field that guides us from start to goal\n// This creates an invisible \"slope\" pointing towards the goal\nlet field = navigation_field(\n  manifold: M,\n  start: start,\n  goal: goal,\n  obstacles: [],\n  cost: geodesic_cost()\n)\n\n// Find the best path that follows the field\nlet path = compute_optimal_path(field)\n\n// Show the path on screen\nvisualize(path, field)\n"}
{"instruction": "Explain this NAVA code in simple terms for someone who has never seen NAVA before.", "input": "let M = euclidean_plane()\nlet obstacle = disc(center: [3.0, 3.0], radius: 1.5)\nlet field = navigation_field(manifold: M, start: [0.0, 0.0], goal: [6.0, 6.0], obstacles: [obstacle])\nlet path = compute_optimal_path(field)\n", "output": "This NAVA code is like giving directions to a robot.\n\nFirst, it says \"we're working on a flat 2D surface\" (euclidean_plane).\n\nThen it says \"there's a circular obstacle here\" (a disc at position 3,3 with radius 1.5).\n\nNext, it creates a navigation field. Think of this like a map with arrows pointing towards the goal, but the arrows also push you away from the obstacle.\n\nFinally, it finds the best path (compute_optimal_path) that follows those arrows while avoiding the obstacle.\n\nSo in one sentence: it finds a safe path from (0,0) to (6,6) that goes around the obstacle."}

