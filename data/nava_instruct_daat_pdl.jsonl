{"instruction": "Write NAVA code for a navigation problem that runs at 50 Hz with a deadline miss rate of at most 0.1% and jitter of at most 20 ms. Include DAAT timing contracts.", "input": "", "output": "program daat_navigation\u22cb\n  -- DAAT Contract: 50Hz, DMR \u2264 0.1%, Jitter \u2264 20ms\n  \n  let navigation_operator\u22cb = \n    deadline\u22cb(\n      frequency\u22cb(50),\n      dmr\u22cb(0.001),\n      jitter\u22cb(20)\n    ) \u2218\u22cb\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    )\n  \n  verify_daat_contract\u22cb(navigation_operator\u22cb, frequency\u22cb(50))\nend program"}
{"instruction": "Write NAVA code for a navigation problem that runs at 200 Hz with a deadline miss rate of at most 0.5% and jitter of at most 10 ms. Include DAAT timing contracts.", "input": "", "output": "program daat_navigation\u22cb\n  -- DAAT Contract: 200Hz, DMR \u2264 0.5%, Jitter \u2264 10ms\n  \n  let navigation_operator\u22cb = \n    deadline\u22cb(\n      frequency\u22cb(200),\n      dmr\u22cb(0.005),\n      jitter\u22cb(10)\n    ) \u2218\u22cb\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    )\n  \n  verify_daat_contract\u22cb(navigation_operator\u22cb, frequency\u22cb(200))\nend program"}
{"instruction": "Write NAVA code for a navigation problem that runs at 100 Hz with a deadline miss rate of at most 1.0% and jitter of at most 20 ms. Include DAAT timing contracts.", "input": "", "output": "program daat_navigation\u22cb\n  -- DAAT Contract: 100Hz, DMR \u2264 1.0%, Jitter \u2264 20ms\n  \n  let navigation_operator\u22cb = \n    deadline\u22cb(\n      frequency\u22cb(100),\n      dmr\u22cb(0.01),\n      jitter\u22cb(20)\n    ) \u2218\u22cb\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    )\n  \n  verify_daat_contract\u22cb(navigation_operator\u22cb, frequency\u22cb(100))\nend program"}
{"instruction": "Write NAVA code for a navigation problem that runs at 200 Hz with a deadline miss rate of at most 0.1% and jitter of at most 5 ms. Include DAAT timing contracts.", "input": "", "output": "program daat_navigation\u22cb\n  -- DAAT Contract: 200Hz, DMR \u2264 0.1%, Jitter \u2264 5ms\n  \n  let navigation_operator\u22cb = \n    deadline\u22cb(\n      frequency\u22cb(200),\n      dmr\u22cb(0.001),\n      jitter\u22cb(5)\n    ) \u2218\u22cb\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    )\n  \n  verify_daat_contract\u22cb(navigation_operator\u22cb, frequency\u22cb(200))\nend program"}
{"instruction": "Write NAVA code for a navigation problem that runs at 100 Hz with a deadline miss rate of at most 0.5% and jitter of at most 5 ms. Include DAAT timing contracts.", "input": "", "output": "program daat_navigation\u22cb\n  -- DAAT Contract: 100Hz, DMR \u2264 0.5%, Jitter \u2264 5ms\n  \n  let navigation_operator\u22cb = \n    deadline\u22cb(\n      frequency\u22cb(100),\n      dmr\u22cb(0.005),\n      jitter\u22cb(5)\n    ) \u2218\u22cb\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    )\n  \n  verify_daat_contract\u22cb(navigation_operator\u22cb, frequency\u22cb(100))\nend program"}
{"instruction": "Write NAVA code for a navigation problem that runs at 100 Hz with a deadline miss rate of at most 0.5% and jitter of at most 10 ms. Include DAAT timing contracts.", "input": "", "output": "program daat_navigation\u22cb\n  -- DAAT Contract: 100Hz, DMR \u2264 0.5%, Jitter \u2264 10ms\n  \n  let navigation_operator\u22cb = \n    deadline\u22cb(\n      frequency\u22cb(100),\n      dmr\u22cb(0.005),\n      jitter\u22cb(10)\n    ) \u2218\u22cb\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    )\n  \n  verify_daat_contract\u22cb(navigation_operator\u22cb, frequency\u22cb(100))\nend program"}
{"instruction": "Write NAVA code for a navigation problem that runs at 200 Hz with a deadline miss rate of at most 1.0% and jitter of at most 5 ms. Include DAAT timing contracts.", "input": "", "output": "program daat_navigation\u22cb\n  -- DAAT Contract: 200Hz, DMR \u2264 1.0%, Jitter \u2264 5ms\n  \n  let navigation_operator\u22cb = \n    deadline\u22cb(\n      frequency\u22cb(200),\n      dmr\u22cb(0.01),\n      jitter\u22cb(5)\n    ) \u2218\u22cb\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    )\n  \n  verify_daat_contract\u22cb(navigation_operator\u22cb, frequency\u22cb(200))\nend program"}
{"instruction": "Write NAVA code for a navigation problem that runs at 50 Hz with a deadline miss rate of at most 0.5% and jitter of at most 10 ms. Include DAAT timing contracts.", "input": "", "output": "program daat_navigation\u22cb\n  -- DAAT Contract: 50Hz, DMR \u2264 0.5%, Jitter \u2264 10ms\n  \n  let navigation_operator\u22cb = \n    deadline\u22cb(\n      frequency\u22cb(50),\n      dmr\u22cb(0.005),\n      jitter\u22cb(10)\n    ) \u2218\u22cb\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    )\n  \n  verify_daat_contract\u22cb(navigation_operator\u22cb, frequency\u22cb(50))\nend program"}
{"instruction": "Write NAVA code for a navigation problem that runs at 50 Hz with a deadline miss rate of at most 1.0% and jitter of at most 10 ms. Include DAAT timing contracts.", "input": "", "output": "program daat_navigation\u22cb\n  -- DAAT Contract: 50Hz, DMR \u2264 1.0%, Jitter \u2264 10ms\n  \n  let navigation_operator\u22cb = \n    deadline\u22cb(\n      frequency\u22cb(50),\n      dmr\u22cb(0.01),\n      jitter\u22cb(10)\n    ) \u2218\u22cb\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    )\n  \n  verify_daat_contract\u22cb(navigation_operator\u22cb, frequency\u22cb(50))\nend program"}
{"instruction": "Write NAVA code for a navigation problem that runs at 200 Hz with a deadline miss rate of at most 0.5% and jitter of at most 10 ms. Include DAAT timing contracts.", "input": "", "output": "program daat_navigation\u22cb\n  -- DAAT Contract: 200Hz, DMR \u2264 0.5%, Jitter \u2264 10ms\n  \n  let navigation_operator\u22cb = \n    deadline\u22cb(\n      frequency\u22cb(200),\n      dmr\u22cb(0.005),\n      jitter\u22cb(10)\n    ) \u2218\u22cb\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    )\n  \n  verify_daat_contract\u22cb(navigation_operator\u22cb, frequency\u22cb(200))\nend program"}
{"instruction": "Write NAVA code for a navigation problem that runs at 200 Hz with a deadline miss rate of at most 0.5% and jitter of at most 10 ms. Include DAAT timing contracts.", "input": "", "output": "program daat_navigation\u22cb\n  -- DAAT Contract: 200Hz, DMR \u2264 0.5%, Jitter \u2264 10ms\n  \n  let navigation_operator\u22cb = \n    deadline\u22cb(\n      frequency\u22cb(200),\n      dmr\u22cb(0.005),\n      jitter\u22cb(10)\n    ) \u2218\u22cb\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    )\n  \n  verify_daat_contract\u22cb(navigation_operator\u22cb, frequency\u22cb(200))\nend program"}
{"instruction": "Write NAVA code for a navigation problem that runs at 200 Hz with a deadline miss rate of at most 0.5% and jitter of at most 10 ms. Include DAAT timing contracts.", "input": "", "output": "program daat_navigation\u22cb\n  -- DAAT Contract: 200Hz, DMR \u2264 0.5%, Jitter \u2264 10ms\n  \n  let navigation_operator\u22cb = \n    deadline\u22cb(\n      frequency\u22cb(200),\n      dmr\u22cb(0.005),\n      jitter\u22cb(10)\n    ) \u2218\u22cb\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    )\n  \n  verify_daat_contract\u22cb(navigation_operator\u22cb, frequency\u22cb(200))\nend program"}
{"instruction": "Write NAVA code for a navigation problem that runs at 50 Hz with a deadline miss rate of at most 0.1% and jitter of at most 20 ms. Include DAAT timing contracts.", "input": "", "output": "program daat_navigation\u22cb\n  -- DAAT Contract: 50Hz, DMR \u2264 0.1%, Jitter \u2264 20ms\n  \n  let navigation_operator\u22cb = \n    deadline\u22cb(\n      frequency\u22cb(50),\n      dmr\u22cb(0.001),\n      jitter\u22cb(20)\n    ) \u2218\u22cb\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    )\n  \n  verify_daat_contract\u22cb(navigation_operator\u22cb, frequency\u22cb(50))\nend program"}
{"instruction": "Write NAVA code for a navigation problem that runs at 50 Hz with a deadline miss rate of at most 0.5% and jitter of at most 20 ms. Include DAAT timing contracts.", "input": "", "output": "program daat_navigation\u22cb\n  -- DAAT Contract: 50Hz, DMR \u2264 0.5%, Jitter \u2264 20ms\n  \n  let navigation_operator\u22cb = \n    deadline\u22cb(\n      frequency\u22cb(50),\n      dmr\u22cb(0.005),\n      jitter\u22cb(20)\n    ) \u2218\u22cb\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    )\n  \n  verify_daat_contract\u22cb(navigation_operator\u22cb, frequency\u22cb(50))\nend program"}
{"instruction": "Write NAVA code for a navigation problem that runs at 200 Hz with a deadline miss rate of at most 0.5% and jitter of at most 5 ms. Include DAAT timing contracts.", "input": "", "output": "program daat_navigation\u22cb\n  -- DAAT Contract: 200Hz, DMR \u2264 0.5%, Jitter \u2264 5ms\n  \n  let navigation_operator\u22cb = \n    deadline\u22cb(\n      frequency\u22cb(200),\n      dmr\u22cb(0.005),\n      jitter\u22cb(5)\n    ) \u2218\u22cb\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    )\n  \n  verify_daat_contract\u22cb(navigation_operator\u22cb, frequency\u22cb(200))\nend program"}
{"instruction": "Write NAVA code for a navigation problem that runs at 100 Hz with a deadline miss rate of at most 0.5% and jitter of at most 20 ms. Include DAAT timing contracts.", "input": "", "output": "program daat_navigation\u22cb\n  -- DAAT Contract: 100Hz, DMR \u2264 0.5%, Jitter \u2264 20ms\n  \n  let navigation_operator\u22cb = \n    deadline\u22cb(\n      frequency\u22cb(100),\n      dmr\u22cb(0.005),\n      jitter\u22cb(20)\n    ) \u2218\u22cb\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    )\n  \n  verify_daat_contract\u22cb(navigation_operator\u22cb, frequency\u22cb(100))\nend program"}
{"instruction": "Write NAVA code for a navigation problem that runs at 50 Hz with a deadline miss rate of at most 1.0% and jitter of at most 5 ms. Include DAAT timing contracts.", "input": "", "output": "program daat_navigation\u22cb\n  -- DAAT Contract: 50Hz, DMR \u2264 1.0%, Jitter \u2264 5ms\n  \n  let navigation_operator\u22cb = \n    deadline\u22cb(\n      frequency\u22cb(50),\n      dmr\u22cb(0.01),\n      jitter\u22cb(5)\n    ) \u2218\u22cb\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    )\n  \n  verify_daat_contract\u22cb(navigation_operator\u22cb, frequency\u22cb(50))\nend program"}
{"instruction": "Write NAVA code for a navigation problem that runs at 100 Hz with a deadline miss rate of at most 0.1% and jitter of at most 5 ms. Include DAAT timing contracts.", "input": "", "output": "program daat_navigation\u22cb\n  -- DAAT Contract: 100Hz, DMR \u2264 0.1%, Jitter \u2264 5ms\n  \n  let navigation_operator\u22cb = \n    deadline\u22cb(\n      frequency\u22cb(100),\n      dmr\u22cb(0.001),\n      jitter\u22cb(5)\n    ) \u2218\u22cb\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    )\n  \n  verify_daat_contract\u22cb(navigation_operator\u22cb, frequency\u22cb(100))\nend program"}
{"instruction": "Write NAVA code for a navigation problem that runs at 50 Hz with a deadline miss rate of at most 0.1% and jitter of at most 20 ms. Include DAAT timing contracts.", "input": "", "output": "program daat_navigation\u22cb\n  -- DAAT Contract: 50Hz, DMR \u2264 0.1%, Jitter \u2264 20ms\n  \n  let navigation_operator\u22cb = \n    deadline\u22cb(\n      frequency\u22cb(50),\n      dmr\u22cb(0.001),\n      jitter\u22cb(20)\n    ) \u2218\u22cb\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    )\n  \n  verify_daat_contract\u22cb(navigation_operator\u22cb, frequency\u22cb(50))\nend program"}
{"instruction": "Write NAVA code for a navigation problem that runs at 50 Hz with a deadline miss rate of at most 0.5% and jitter of at most 20 ms. Include DAAT timing contracts.", "input": "", "output": "program daat_navigation\u22cb\n  -- DAAT Contract: 50Hz, DMR \u2264 0.5%, Jitter \u2264 20ms\n  \n  let navigation_operator\u22cb = \n    deadline\u22cb(\n      frequency\u22cb(50),\n      dmr\u22cb(0.005),\n      jitter\u22cb(20)\n    ) \u2218\u22cb\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    )\n  \n  verify_daat_contract\u22cb(navigation_operator\u22cb, frequency\u22cb(50))\nend program"}
{"instruction": "Write NAVA code with a multi-tier PDL architecture: Tier-0 for reflex actions (<1ms), Tier-1 for chunked VLA calls (10ms budget), and Tier-2 for offline planning. Use hierarchical composition with fallbacks.", "input": "", "output": "program pdl_navigation\u22cb\n  -- PDL: Policy Description Language with tiered architecture\n  \n  -- Tier-0: Reflex policy (fastest, <1ms)\n  let tier0_reflex\u22cb = reflex_policy\u22cb(\n    emergency_stop\u22cb(),\n    collision_avoidance\u22cb(),\n    timeout\u22cb(1ms)\n  )\n  \n  -- Tier-1: Chunked VLA call with time budget\n  let tier1_vla\u22cb = vla_chunked\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    time_budget\u22cb(10ms),\n    chunk_size\u22cb(32)\n  )\n  \n  -- Tier-2: Offline planner (can take longer)\n  let tier2_planner\u22cb = offline_planner\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    optimization_horizon\u22cb(100)\n  )\n  \n  -- Hierarchical composition\n  let hierarchical_control\u22cb = \n    tier2_planner\u22cb \n    |> fallback_to\u22cb(tier1_vla\u22cb)\n    |> emergency_to\u22cb(tier0_reflex\u22cb)\nend program"}
{"instruction": "Write NAVA code with a multi-tier PDL architecture: Tier-0 for reflex actions (<1ms), Tier-1 for chunked VLA calls (10ms budget), and Tier-2 for offline planning. Use hierarchical composition with fallbacks.", "input": "", "output": "program pdl_navigation\u22cb\n  -- PDL: Policy Description Language with tiered architecture\n  \n  -- Tier-0: Reflex policy (fastest, <1ms)\n  let tier0_reflex\u22cb = reflex_policy\u22cb(\n    emergency_stop\u22cb(),\n    collision_avoidance\u22cb(),\n    timeout\u22cb(1ms)\n  )\n  \n  -- Tier-1: Chunked VLA call with time budget\n  let tier1_vla\u22cb = vla_chunked\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    time_budget\u22cb(10ms),\n    chunk_size\u22cb(32)\n  )\n  \n  -- Tier-2: Offline planner (can take longer)\n  let tier2_planner\u22cb = offline_planner\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    optimization_horizon\u22cb(100)\n  )\n  \n  -- Hierarchical composition\n  let hierarchical_control\u22cb = \n    tier2_planner\u22cb \n    |> fallback_to\u22cb(tier1_vla\u22cb)\n    |> emergency_to\u22cb(tier0_reflex\u22cb)\nend program"}
{"instruction": "Write NAVA code with a multi-tier PDL architecture: Tier-0 for reflex actions (<1ms), Tier-1 for chunked VLA calls (10ms budget), and Tier-2 for offline planning. Use hierarchical composition with fallbacks.", "input": "", "output": "program pdl_navigation\u22cb\n  -- PDL: Policy Description Language with tiered architecture\n  \n  -- Tier-0: Reflex policy (fastest, <1ms)\n  let tier0_reflex\u22cb = reflex_policy\u22cb(\n    emergency_stop\u22cb(),\n    collision_avoidance\u22cb(),\n    timeout\u22cb(1ms)\n  )\n  \n  -- Tier-1: Chunked VLA call with time budget\n  let tier1_vla\u22cb = vla_chunked\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    time_budget\u22cb(10ms),\n    chunk_size\u22cb(32)\n  )\n  \n  -- Tier-2: Offline planner (can take longer)\n  let tier2_planner\u22cb = offline_planner\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    optimization_horizon\u22cb(100)\n  )\n  \n  -- Hierarchical composition\n  let hierarchical_control\u22cb = \n    tier2_planner\u22cb \n    |> fallback_to\u22cb(tier1_vla\u22cb)\n    |> emergency_to\u22cb(tier0_reflex\u22cb)\nend program"}
{"instruction": "Write NAVA code with a multi-tier PDL architecture: Tier-0 for reflex actions (<1ms), Tier-1 for chunked VLA calls (10ms budget), and Tier-2 for offline planning. Use hierarchical composition with fallbacks.", "input": "", "output": "program pdl_navigation\u22cb\n  -- PDL: Policy Description Language with tiered architecture\n  \n  -- Tier-0: Reflex policy (fastest, <1ms)\n  let tier0_reflex\u22cb = reflex_policy\u22cb(\n    emergency_stop\u22cb(),\n    collision_avoidance\u22cb(),\n    timeout\u22cb(1ms)\n  )\n  \n  -- Tier-1: Chunked VLA call with time budget\n  let tier1_vla\u22cb = vla_chunked\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    time_budget\u22cb(10ms),\n    chunk_size\u22cb(32)\n  )\n  \n  -- Tier-2: Offline planner (can take longer)\n  let tier2_planner\u22cb = offline_planner\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    optimization_horizon\u22cb(100)\n  )\n  \n  -- Hierarchical composition\n  let hierarchical_control\u22cb = \n    tier2_planner\u22cb \n    |> fallback_to\u22cb(tier1_vla\u22cb)\n    |> emergency_to\u22cb(tier0_reflex\u22cb)\nend program"}
{"instruction": "Write NAVA code with a multi-tier PDL architecture: Tier-0 for reflex actions (<1ms), Tier-1 for chunked VLA calls (10ms budget), and Tier-2 for offline planning. Use hierarchical composition with fallbacks.", "input": "", "output": "program pdl_navigation\u22cb\n  -- PDL: Policy Description Language with tiered architecture\n  \n  -- Tier-0: Reflex policy (fastest, <1ms)\n  let tier0_reflex\u22cb = reflex_policy\u22cb(\n    emergency_stop\u22cb(),\n    collision_avoidance\u22cb(),\n    timeout\u22cb(1ms)\n  )\n  \n  -- Tier-1: Chunked VLA call with time budget\n  let tier1_vla\u22cb = vla_chunked\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    time_budget\u22cb(10ms),\n    chunk_size\u22cb(32)\n  )\n  \n  -- Tier-2: Offline planner (can take longer)\n  let tier2_planner\u22cb = offline_planner\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    optimization_horizon\u22cb(100)\n  )\n  \n  -- Hierarchical composition\n  let hierarchical_control\u22cb = \n    tier2_planner\u22cb \n    |> fallback_to\u22cb(tier1_vla\u22cb)\n    |> emergency_to\u22cb(tier0_reflex\u22cb)\nend program"}
{"instruction": "Write NAVA code with a multi-tier PDL architecture: Tier-0 for reflex actions (<1ms), Tier-1 for chunked VLA calls (10ms budget), and Tier-2 for offline planning. Use hierarchical composition with fallbacks.", "input": "", "output": "program pdl_navigation\u22cb\n  -- PDL: Policy Description Language with tiered architecture\n  \n  -- Tier-0: Reflex policy (fastest, <1ms)\n  let tier0_reflex\u22cb = reflex_policy\u22cb(\n    emergency_stop\u22cb(),\n    collision_avoidance\u22cb(),\n    timeout\u22cb(1ms)\n  )\n  \n  -- Tier-1: Chunked VLA call with time budget\n  let tier1_vla\u22cb = vla_chunked\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    time_budget\u22cb(10ms),\n    chunk_size\u22cb(32)\n  )\n  \n  -- Tier-2: Offline planner (can take longer)\n  let tier2_planner\u22cb = offline_planner\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    optimization_horizon\u22cb(100)\n  )\n  \n  -- Hierarchical composition\n  let hierarchical_control\u22cb = \n    tier2_planner\u22cb \n    |> fallback_to\u22cb(tier1_vla\u22cb)\n    |> emergency_to\u22cb(tier0_reflex\u22cb)\nend program"}
{"instruction": "Write NAVA code with a multi-tier PDL architecture: Tier-0 for reflex actions (<1ms), Tier-1 for chunked VLA calls (10ms budget), and Tier-2 for offline planning. Use hierarchical composition with fallbacks.", "input": "", "output": "program pdl_navigation\u22cb\n  -- PDL: Policy Description Language with tiered architecture\n  \n  -- Tier-0: Reflex policy (fastest, <1ms)\n  let tier0_reflex\u22cb = reflex_policy\u22cb(\n    emergency_stop\u22cb(),\n    collision_avoidance\u22cb(),\n    timeout\u22cb(1ms)\n  )\n  \n  -- Tier-1: Chunked VLA call with time budget\n  let tier1_vla\u22cb = vla_chunked\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    time_budget\u22cb(10ms),\n    chunk_size\u22cb(32)\n  )\n  \n  -- Tier-2: Offline planner (can take longer)\n  let tier2_planner\u22cb = offline_planner\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    optimization_horizon\u22cb(100)\n  )\n  \n  -- Hierarchical composition\n  let hierarchical_control\u22cb = \n    tier2_planner\u22cb \n    |> fallback_to\u22cb(tier1_vla\u22cb)\n    |> emergency_to\u22cb(tier0_reflex\u22cb)\nend program"}
{"instruction": "Write NAVA code with a multi-tier PDL architecture: Tier-0 for reflex actions (<1ms), Tier-1 for chunked VLA calls (10ms budget), and Tier-2 for offline planning. Use hierarchical composition with fallbacks.", "input": "", "output": "program pdl_navigation\u22cb\n  -- PDL: Policy Description Language with tiered architecture\n  \n  -- Tier-0: Reflex policy (fastest, <1ms)\n  let tier0_reflex\u22cb = reflex_policy\u22cb(\n    emergency_stop\u22cb(),\n    collision_avoidance\u22cb(),\n    timeout\u22cb(1ms)\n  )\n  \n  -- Tier-1: Chunked VLA call with time budget\n  let tier1_vla\u22cb = vla_chunked\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    time_budget\u22cb(10ms),\n    chunk_size\u22cb(32)\n  )\n  \n  -- Tier-2: Offline planner (can take longer)\n  let tier2_planner\u22cb = offline_planner\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    optimization_horizon\u22cb(100)\n  )\n  \n  -- Hierarchical composition\n  let hierarchical_control\u22cb = \n    tier2_planner\u22cb \n    |> fallback_to\u22cb(tier1_vla\u22cb)\n    |> emergency_to\u22cb(tier0_reflex\u22cb)\nend program"}
{"instruction": "Write NAVA code with a multi-tier PDL architecture: Tier-0 for reflex actions (<1ms), Tier-1 for chunked VLA calls (10ms budget), and Tier-2 for offline planning. Use hierarchical composition with fallbacks.", "input": "", "output": "program pdl_navigation\u22cb\n  -- PDL: Policy Description Language with tiered architecture\n  \n  -- Tier-0: Reflex policy (fastest, <1ms)\n  let tier0_reflex\u22cb = reflex_policy\u22cb(\n    emergency_stop\u22cb(),\n    collision_avoidance\u22cb(),\n    timeout\u22cb(1ms)\n  )\n  \n  -- Tier-1: Chunked VLA call with time budget\n  let tier1_vla\u22cb = vla_chunked\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    time_budget\u22cb(10ms),\n    chunk_size\u22cb(32)\n  )\n  \n  -- Tier-2: Offline planner (can take longer)\n  let tier2_planner\u22cb = offline_planner\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    optimization_horizon\u22cb(100)\n  )\n  \n  -- Hierarchical composition\n  let hierarchical_control\u22cb = \n    tier2_planner\u22cb \n    |> fallback_to\u22cb(tier1_vla\u22cb)\n    |> emergency_to\u22cb(tier0_reflex\u22cb)\nend program"}
{"instruction": "Write NAVA code with a multi-tier PDL architecture: Tier-0 for reflex actions (<1ms), Tier-1 for chunked VLA calls (10ms budget), and Tier-2 for offline planning. Use hierarchical composition with fallbacks.", "input": "", "output": "program pdl_navigation\u22cb\n  -- PDL: Policy Description Language with tiered architecture\n  \n  -- Tier-0: Reflex policy (fastest, <1ms)\n  let tier0_reflex\u22cb = reflex_policy\u22cb(\n    emergency_stop\u22cb(),\n    collision_avoidance\u22cb(),\n    timeout\u22cb(1ms)\n  )\n  \n  -- Tier-1: Chunked VLA call with time budget\n  let tier1_vla\u22cb = vla_chunked\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    time_budget\u22cb(10ms),\n    chunk_size\u22cb(32)\n  )\n  \n  -- Tier-2: Offline planner (can take longer)\n  let tier2_planner\u22cb = offline_planner\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    optimization_horizon\u22cb(100)\n  )\n  \n  -- Hierarchical composition\n  let hierarchical_control\u22cb = \n    tier2_planner\u22cb \n    |> fallback_to\u22cb(tier1_vla\u22cb)\n    |> emergency_to\u22cb(tier0_reflex\u22cb)\nend program"}
{"instruction": "Write NAVA code with a multi-tier PDL architecture: Tier-0 for reflex actions (<1ms), Tier-1 for chunked VLA calls (10ms budget), and Tier-2 for offline planning. Use hierarchical composition with fallbacks.", "input": "", "output": "program pdl_navigation\u22cb\n  -- PDL: Policy Description Language with tiered architecture\n  \n  -- Tier-0: Reflex policy (fastest, <1ms)\n  let tier0_reflex\u22cb = reflex_policy\u22cb(\n    emergency_stop\u22cb(),\n    collision_avoidance\u22cb(),\n    timeout\u22cb(1ms)\n  )\n  \n  -- Tier-1: Chunked VLA call with time budget\n  let tier1_vla\u22cb = vla_chunked\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    time_budget\u22cb(10ms),\n    chunk_size\u22cb(32)\n  )\n  \n  -- Tier-2: Offline planner (can take longer)\n  let tier2_planner\u22cb = offline_planner\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    optimization_horizon\u22cb(100)\n  )\n  \n  -- Hierarchical composition\n  let hierarchical_control\u22cb = \n    tier2_planner\u22cb \n    |> fallback_to\u22cb(tier1_vla\u22cb)\n    |> emergency_to\u22cb(tier0_reflex\u22cb)\nend program"}
{"instruction": "Write NAVA code with a multi-tier PDL architecture: Tier-0 for reflex actions (<1ms), Tier-1 for chunked VLA calls (10ms budget), and Tier-2 for offline planning. Use hierarchical composition with fallbacks.", "input": "", "output": "program pdl_navigation\u22cb\n  -- PDL: Policy Description Language with tiered architecture\n  \n  -- Tier-0: Reflex policy (fastest, <1ms)\n  let tier0_reflex\u22cb = reflex_policy\u22cb(\n    emergency_stop\u22cb(),\n    collision_avoidance\u22cb(),\n    timeout\u22cb(1ms)\n  )\n  \n  -- Tier-1: Chunked VLA call with time budget\n  let tier1_vla\u22cb = vla_chunked\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    time_budget\u22cb(10ms),\n    chunk_size\u22cb(32)\n  )\n  \n  -- Tier-2: Offline planner (can take longer)\n  let tier2_planner\u22cb = offline_planner\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    optimization_horizon\u22cb(100)\n  )\n  \n  -- Hierarchical composition\n  let hierarchical_control\u22cb = \n    tier2_planner\u22cb \n    |> fallback_to\u22cb(tier1_vla\u22cb)\n    |> emergency_to\u22cb(tier0_reflex\u22cb)\nend program"}
{"instruction": "Write NAVA code with a multi-tier PDL architecture: Tier-0 for reflex actions (<1ms), Tier-1 for chunked VLA calls (10ms budget), and Tier-2 for offline planning. Use hierarchical composition with fallbacks.", "input": "", "output": "program pdl_navigation\u22cb\n  -- PDL: Policy Description Language with tiered architecture\n  \n  -- Tier-0: Reflex policy (fastest, <1ms)\n  let tier0_reflex\u22cb = reflex_policy\u22cb(\n    emergency_stop\u22cb(),\n    collision_avoidance\u22cb(),\n    timeout\u22cb(1ms)\n  )\n  \n  -- Tier-1: Chunked VLA call with time budget\n  let tier1_vla\u22cb = vla_chunked\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    time_budget\u22cb(10ms),\n    chunk_size\u22cb(32)\n  )\n  \n  -- Tier-2: Offline planner (can take longer)\n  let tier2_planner\u22cb = offline_planner\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    optimization_horizon\u22cb(100)\n  )\n  \n  -- Hierarchical composition\n  let hierarchical_control\u22cb = \n    tier2_planner\u22cb \n    |> fallback_to\u22cb(tier1_vla\u22cb)\n    |> emergency_to\u22cb(tier0_reflex\u22cb)\nend program"}
{"instruction": "Write NAVA code with a multi-tier PDL architecture: Tier-0 for reflex actions (<1ms), Tier-1 for chunked VLA calls (10ms budget), and Tier-2 for offline planning. Use hierarchical composition with fallbacks.", "input": "", "output": "program pdl_navigation\u22cb\n  -- PDL: Policy Description Language with tiered architecture\n  \n  -- Tier-0: Reflex policy (fastest, <1ms)\n  let tier0_reflex\u22cb = reflex_policy\u22cb(\n    emergency_stop\u22cb(),\n    collision_avoidance\u22cb(),\n    timeout\u22cb(1ms)\n  )\n  \n  -- Tier-1: Chunked VLA call with time budget\n  let tier1_vla\u22cb = vla_chunked\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    time_budget\u22cb(10ms),\n    chunk_size\u22cb(32)\n  )\n  \n  -- Tier-2: Offline planner (can take longer)\n  let tier2_planner\u22cb = offline_planner\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    optimization_horizon\u22cb(100)\n  )\n  \n  -- Hierarchical composition\n  let hierarchical_control\u22cb = \n    tier2_planner\u22cb \n    |> fallback_to\u22cb(tier1_vla\u22cb)\n    |> emergency_to\u22cb(tier0_reflex\u22cb)\nend program"}
{"instruction": "Write NAVA code with a multi-tier PDL architecture: Tier-0 for reflex actions (<1ms), Tier-1 for chunked VLA calls (10ms budget), and Tier-2 for offline planning. Use hierarchical composition with fallbacks.", "input": "", "output": "program pdl_navigation\u22cb\n  -- PDL: Policy Description Language with tiered architecture\n  \n  -- Tier-0: Reflex policy (fastest, <1ms)\n  let tier0_reflex\u22cb = reflex_policy\u22cb(\n    emergency_stop\u22cb(),\n    collision_avoidance\u22cb(),\n    timeout\u22cb(1ms)\n  )\n  \n  -- Tier-1: Chunked VLA call with time budget\n  let tier1_vla\u22cb = vla_chunked\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    time_budget\u22cb(10ms),\n    chunk_size\u22cb(32)\n  )\n  \n  -- Tier-2: Offline planner (can take longer)\n  let tier2_planner\u22cb = offline_planner\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    optimization_horizon\u22cb(100)\n  )\n  \n  -- Hierarchical composition\n  let hierarchical_control\u22cb = \n    tier2_planner\u22cb \n    |> fallback_to\u22cb(tier1_vla\u22cb)\n    |> emergency_to\u22cb(tier0_reflex\u22cb)\nend program"}
{"instruction": "Write NAVA code with a multi-tier PDL architecture: Tier-0 for reflex actions (<1ms), Tier-1 for chunked VLA calls (10ms budget), and Tier-2 for offline planning. Use hierarchical composition with fallbacks.", "input": "", "output": "program pdl_navigation\u22cb\n  -- PDL: Policy Description Language with tiered architecture\n  \n  -- Tier-0: Reflex policy (fastest, <1ms)\n  let tier0_reflex\u22cb = reflex_policy\u22cb(\n    emergency_stop\u22cb(),\n    collision_avoidance\u22cb(),\n    timeout\u22cb(1ms)\n  )\n  \n  -- Tier-1: Chunked VLA call with time budget\n  let tier1_vla\u22cb = vla_chunked\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    time_budget\u22cb(10ms),\n    chunk_size\u22cb(32)\n  )\n  \n  -- Tier-2: Offline planner (can take longer)\n  let tier2_planner\u22cb = offline_planner\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    optimization_horizon\u22cb(100)\n  )\n  \n  -- Hierarchical composition\n  let hierarchical_control\u22cb = \n    tier2_planner\u22cb \n    |> fallback_to\u22cb(tier1_vla\u22cb)\n    |> emergency_to\u22cb(tier0_reflex\u22cb)\nend program"}
{"instruction": "Write NAVA code with a multi-tier PDL architecture: Tier-0 for reflex actions (<1ms), Tier-1 for chunked VLA calls (10ms budget), and Tier-2 for offline planning. Use hierarchical composition with fallbacks.", "input": "", "output": "program pdl_navigation\u22cb\n  -- PDL: Policy Description Language with tiered architecture\n  \n  -- Tier-0: Reflex policy (fastest, <1ms)\n  let tier0_reflex\u22cb = reflex_policy\u22cb(\n    emergency_stop\u22cb(),\n    collision_avoidance\u22cb(),\n    timeout\u22cb(1ms)\n  )\n  \n  -- Tier-1: Chunked VLA call with time budget\n  let tier1_vla\u22cb = vla_chunked\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    time_budget\u22cb(10ms),\n    chunk_size\u22cb(32)\n  )\n  \n  -- Tier-2: Offline planner (can take longer)\n  let tier2_planner\u22cb = offline_planner\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    optimization_horizon\u22cb(100)\n  )\n  \n  -- Hierarchical composition\n  let hierarchical_control\u22cb = \n    tier2_planner\u22cb \n    |> fallback_to\u22cb(tier1_vla\u22cb)\n    |> emergency_to\u22cb(tier0_reflex\u22cb)\nend program"}
{"instruction": "Write NAVA code with a multi-tier PDL architecture: Tier-0 for reflex actions (<1ms), Tier-1 for chunked VLA calls (10ms budget), and Tier-2 for offline planning. Use hierarchical composition with fallbacks.", "input": "", "output": "program pdl_navigation\u22cb\n  -- PDL: Policy Description Language with tiered architecture\n  \n  -- Tier-0: Reflex policy (fastest, <1ms)\n  let tier0_reflex\u22cb = reflex_policy\u22cb(\n    emergency_stop\u22cb(),\n    collision_avoidance\u22cb(),\n    timeout\u22cb(1ms)\n  )\n  \n  -- Tier-1: Chunked VLA call with time budget\n  let tier1_vla\u22cb = vla_chunked\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    time_budget\u22cb(10ms),\n    chunk_size\u22cb(32)\n  )\n  \n  -- Tier-2: Offline planner (can take longer)\n  let tier2_planner\u22cb = offline_planner\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    optimization_horizon\u22cb(100)\n  )\n  \n  -- Hierarchical composition\n  let hierarchical_control\u22cb = \n    tier2_planner\u22cb \n    |> fallback_to\u22cb(tier1_vla\u22cb)\n    |> emergency_to\u22cb(tier0_reflex\u22cb)\nend program"}
{"instruction": "Write NAVA code with a multi-tier PDL architecture: Tier-0 for reflex actions (<1ms), Tier-1 for chunked VLA calls (10ms budget), and Tier-2 for offline planning. Use hierarchical composition with fallbacks.", "input": "", "output": "program pdl_navigation\u22cb\n  -- PDL: Policy Description Language with tiered architecture\n  \n  -- Tier-0: Reflex policy (fastest, <1ms)\n  let tier0_reflex\u22cb = reflex_policy\u22cb(\n    emergency_stop\u22cb(),\n    collision_avoidance\u22cb(),\n    timeout\u22cb(1ms)\n  )\n  \n  -- Tier-1: Chunked VLA call with time budget\n  let tier1_vla\u22cb = vla_chunked\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    time_budget\u22cb(10ms),\n    chunk_size\u22cb(32)\n  )\n  \n  -- Tier-2: Offline planner (can take longer)\n  let tier2_planner\u22cb = offline_planner\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    optimization_horizon\u22cb(100)\n  )\n  \n  -- Hierarchical composition\n  let hierarchical_control\u22cb = \n    tier2_planner\u22cb \n    |> fallback_to\u22cb(tier1_vla\u22cb)\n    |> emergency_to\u22cb(tier0_reflex\u22cb)\nend program"}
{"instruction": "Write NAVA code with a multi-tier PDL architecture: Tier-0 for reflex actions (<1ms), Tier-1 for chunked VLA calls (10ms budget), and Tier-2 for offline planning. Use hierarchical composition with fallbacks.", "input": "", "output": "program pdl_navigation\u22cb\n  -- PDL: Policy Description Language with tiered architecture\n  \n  -- Tier-0: Reflex policy (fastest, <1ms)\n  let tier0_reflex\u22cb = reflex_policy\u22cb(\n    emergency_stop\u22cb(),\n    collision_avoidance\u22cb(),\n    timeout\u22cb(1ms)\n  )\n  \n  -- Tier-1: Chunked VLA call with time budget\n  let tier1_vla\u22cb = vla_chunked\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    time_budget\u22cb(10ms),\n    chunk_size\u22cb(32)\n  )\n  \n  -- Tier-2: Offline planner (can take longer)\n  let tier2_planner\u22cb = offline_planner\u22cb(\n    (\n      let M = euclidean_plane()\n      let start = [0.0, 0.0]\n      let goal = [5.0, 5.0]\n      let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n      let path = compute_optimal_path(field)\n    ),\n    optimization_horizon\u22cb(100)\n  )\n  \n  -- Hierarchical composition\n  let hierarchical_control\u22cb = \n    tier2_planner\u22cb \n    |> fallback_to\u22cb(tier1_vla\u22cb)\n    |> emergency_to\u22cb(tier0_reflex\u22cb)\nend program"}
{"instruction": "Write NAVA code with RT-shields timing contracts: DMR \u2264 0.5%, arrival jitter (p95) \u2264 10ms, time-to-process \u2264 10ms, and time-to-budget \u2264 100ms. Include contract verification.", "input": "", "output": "program rt_shields_navigation\u22cb\n  -- RT-shields: Real-time safety contracts\n  \n  let navigation_controller\u22cb = (\n    let M = euclidean_plane()\n    let start = [0.0, 0.0]\n    let goal = [5.0, 5.0]\n    let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n    let path = compute_optimal_path(field)\n  )\n  \n  -- RT-shields contract\n  let timing_contract\u22cb = rt_shield_contract\u22cb(\n    dmr_threshold\u22cb(0.005),      -- DMR \u2264 0.5%\n    aj_p95_threshold\u22cb(10),      -- AJ p95 \u2264 10ms\n    ttp_threshold\u22cb(10),         -- TTP \u2264 10ms\n    ttb_threshold\u22cb(100)         -- TTB \u2264 100ms\n  )\n  \n  -- Verify contract\n  verify_rt_shield\u22cb(navigation_controller\u22cb, timing_contract\u22cb)\nend program"}
{"instruction": "Write NAVA code with RT-shields timing contracts: DMR \u2264 0.5%, arrival jitter (p95) \u2264 10ms, time-to-process \u2264 10ms, and time-to-budget \u2264 100ms. Include contract verification.", "input": "", "output": "program rt_shields_navigation\u22cb\n  -- RT-shields: Real-time safety contracts\n  \n  let navigation_controller\u22cb = (\n    let M = euclidean_plane()\n    let start = [0.0, 0.0]\n    let goal = [5.0, 5.0]\n    let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n    let path = compute_optimal_path(field)\n  )\n  \n  -- RT-shields contract\n  let timing_contract\u22cb = rt_shield_contract\u22cb(\n    dmr_threshold\u22cb(0.005),      -- DMR \u2264 0.5%\n    aj_p95_threshold\u22cb(10),      -- AJ p95 \u2264 10ms\n    ttp_threshold\u22cb(10),         -- TTP \u2264 10ms\n    ttb_threshold\u22cb(100)         -- TTB \u2264 100ms\n  )\n  \n  -- Verify contract\n  verify_rt_shield\u22cb(navigation_controller\u22cb, timing_contract\u22cb)\nend program"}
{"instruction": "Write NAVA code with RT-shields timing contracts: DMR \u2264 0.5%, arrival jitter (p95) \u2264 10ms, time-to-process \u2264 10ms, and time-to-budget \u2264 100ms. Include contract verification.", "input": "", "output": "program rt_shields_navigation\u22cb\n  -- RT-shields: Real-time safety contracts\n  \n  let navigation_controller\u22cb = (\n    let M = euclidean_plane()\n    let start = [0.0, 0.0]\n    let goal = [5.0, 5.0]\n    let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n    let path = compute_optimal_path(field)\n  )\n  \n  -- RT-shields contract\n  let timing_contract\u22cb = rt_shield_contract\u22cb(\n    dmr_threshold\u22cb(0.005),      -- DMR \u2264 0.5%\n    aj_p95_threshold\u22cb(10),      -- AJ p95 \u2264 10ms\n    ttp_threshold\u22cb(10),         -- TTP \u2264 10ms\n    ttb_threshold\u22cb(100)         -- TTB \u2264 100ms\n  )\n  \n  -- Verify contract\n  verify_rt_shield\u22cb(navigation_controller\u22cb, timing_contract\u22cb)\nend program"}
{"instruction": "Write NAVA code with RT-shields timing contracts: DMR \u2264 0.5%, arrival jitter (p95) \u2264 10ms, time-to-process \u2264 10ms, and time-to-budget \u2264 100ms. Include contract verification.", "input": "", "output": "program rt_shields_navigation\u22cb\n  -- RT-shields: Real-time safety contracts\n  \n  let navigation_controller\u22cb = (\n    let M = euclidean_plane()\n    let start = [0.0, 0.0]\n    let goal = [5.0, 5.0]\n    let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n    let path = compute_optimal_path(field)\n  )\n  \n  -- RT-shields contract\n  let timing_contract\u22cb = rt_shield_contract\u22cb(\n    dmr_threshold\u22cb(0.005),      -- DMR \u2264 0.5%\n    aj_p95_threshold\u22cb(10),      -- AJ p95 \u2264 10ms\n    ttp_threshold\u22cb(10),         -- TTP \u2264 10ms\n    ttb_threshold\u22cb(100)         -- TTB \u2264 100ms\n  )\n  \n  -- Verify contract\n  verify_rt_shield\u22cb(navigation_controller\u22cb, timing_contract\u22cb)\nend program"}
{"instruction": "Write NAVA code with RT-shields timing contracts: DMR \u2264 0.5%, arrival jitter (p95) \u2264 10ms, time-to-process \u2264 10ms, and time-to-budget \u2264 100ms. Include contract verification.", "input": "", "output": "program rt_shields_navigation\u22cb\n  -- RT-shields: Real-time safety contracts\n  \n  let navigation_controller\u22cb = (\n    let M = euclidean_plane()\n    let start = [0.0, 0.0]\n    let goal = [5.0, 5.0]\n    let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n    let path = compute_optimal_path(field)\n  )\n  \n  -- RT-shields contract\n  let timing_contract\u22cb = rt_shield_contract\u22cb(\n    dmr_threshold\u22cb(0.005),      -- DMR \u2264 0.5%\n    aj_p95_threshold\u22cb(10),      -- AJ p95 \u2264 10ms\n    ttp_threshold\u22cb(10),         -- TTP \u2264 10ms\n    ttb_threshold\u22cb(100)         -- TTB \u2264 100ms\n  )\n  \n  -- Verify contract\n  verify_rt_shield\u22cb(navigation_controller\u22cb, timing_contract\u22cb)\nend program"}
{"instruction": "Write NAVA code with RT-shields timing contracts: DMR \u2264 0.5%, arrival jitter (p95) \u2264 10ms, time-to-process \u2264 10ms, and time-to-budget \u2264 100ms. Include contract verification.", "input": "", "output": "program rt_shields_navigation\u22cb\n  -- RT-shields: Real-time safety contracts\n  \n  let navigation_controller\u22cb = (\n    let M = euclidean_plane()\n    let start = [0.0, 0.0]\n    let goal = [5.0, 5.0]\n    let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n    let path = compute_optimal_path(field)\n  )\n  \n  -- RT-shields contract\n  let timing_contract\u22cb = rt_shield_contract\u22cb(\n    dmr_threshold\u22cb(0.005),      -- DMR \u2264 0.5%\n    aj_p95_threshold\u22cb(10),      -- AJ p95 \u2264 10ms\n    ttp_threshold\u22cb(10),         -- TTP \u2264 10ms\n    ttb_threshold\u22cb(100)         -- TTB \u2264 100ms\n  )\n  \n  -- Verify contract\n  verify_rt_shield\u22cb(navigation_controller\u22cb, timing_contract\u22cb)\nend program"}
{"instruction": "Write NAVA code with RT-shields timing contracts: DMR \u2264 0.5%, arrival jitter (p95) \u2264 10ms, time-to-process \u2264 10ms, and time-to-budget \u2264 100ms. Include contract verification.", "input": "", "output": "program rt_shields_navigation\u22cb\n  -- RT-shields: Real-time safety contracts\n  \n  let navigation_controller\u22cb = (\n    let M = euclidean_plane()\n    let start = [0.0, 0.0]\n    let goal = [5.0, 5.0]\n    let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n    let path = compute_optimal_path(field)\n  )\n  \n  -- RT-shields contract\n  let timing_contract\u22cb = rt_shield_contract\u22cb(\n    dmr_threshold\u22cb(0.005),      -- DMR \u2264 0.5%\n    aj_p95_threshold\u22cb(10),      -- AJ p95 \u2264 10ms\n    ttp_threshold\u22cb(10),         -- TTP \u2264 10ms\n    ttb_threshold\u22cb(100)         -- TTB \u2264 100ms\n  )\n  \n  -- Verify contract\n  verify_rt_shield\u22cb(navigation_controller\u22cb, timing_contract\u22cb)\nend program"}
{"instruction": "Write NAVA code with RT-shields timing contracts: DMR \u2264 0.5%, arrival jitter (p95) \u2264 10ms, time-to-process \u2264 10ms, and time-to-budget \u2264 100ms. Include contract verification.", "input": "", "output": "program rt_shields_navigation\u22cb\n  -- RT-shields: Real-time safety contracts\n  \n  let navigation_controller\u22cb = (\n    let M = euclidean_plane()\n    let start = [0.0, 0.0]\n    let goal = [5.0, 5.0]\n    let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n    let path = compute_optimal_path(field)\n  )\n  \n  -- RT-shields contract\n  let timing_contract\u22cb = rt_shield_contract\u22cb(\n    dmr_threshold\u22cb(0.005),      -- DMR \u2264 0.5%\n    aj_p95_threshold\u22cb(10),      -- AJ p95 \u2264 10ms\n    ttp_threshold\u22cb(10),         -- TTP \u2264 10ms\n    ttb_threshold\u22cb(100)         -- TTB \u2264 100ms\n  )\n  \n  -- Verify contract\n  verify_rt_shield\u22cb(navigation_controller\u22cb, timing_contract\u22cb)\nend program"}
{"instruction": "Write NAVA code with RT-shields timing contracts: DMR \u2264 0.5%, arrival jitter (p95) \u2264 10ms, time-to-process \u2264 10ms, and time-to-budget \u2264 100ms. Include contract verification.", "input": "", "output": "program rt_shields_navigation\u22cb\n  -- RT-shields: Real-time safety contracts\n  \n  let navigation_controller\u22cb = (\n    let M = euclidean_plane()\n    let start = [0.0, 0.0]\n    let goal = [5.0, 5.0]\n    let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n    let path = compute_optimal_path(field)\n  )\n  \n  -- RT-shields contract\n  let timing_contract\u22cb = rt_shield_contract\u22cb(\n    dmr_threshold\u22cb(0.005),      -- DMR \u2264 0.5%\n    aj_p95_threshold\u22cb(10),      -- AJ p95 \u2264 10ms\n    ttp_threshold\u22cb(10),         -- TTP \u2264 10ms\n    ttb_threshold\u22cb(100)         -- TTB \u2264 100ms\n  )\n  \n  -- Verify contract\n  verify_rt_shield\u22cb(navigation_controller\u22cb, timing_contract\u22cb)\nend program"}
{"instruction": "Write NAVA code with RT-shields timing contracts: DMR \u2264 0.5%, arrival jitter (p95) \u2264 10ms, time-to-process \u2264 10ms, and time-to-budget \u2264 100ms. Include contract verification.", "input": "", "output": "program rt_shields_navigation\u22cb\n  -- RT-shields: Real-time safety contracts\n  \n  let navigation_controller\u22cb = (\n    let M = euclidean_plane()\n    let start = [0.0, 0.0]\n    let goal = [5.0, 5.0]\n    let field = navigation_field(manifold: M, start: start, goal: goal, obstacles: [], cost: geodesic_cost())\n    let path = compute_optimal_path(field)\n  )\n  \n  -- RT-shields contract\n  let timing_contract\u22cb = rt_shield_contract\u22cb(\n    dmr_threshold\u22cb(0.005),      -- DMR \u2264 0.5%\n    aj_p95_threshold\u22cb(10),      -- AJ p95 \u2264 10ms\n    ttp_threshold\u22cb(10),         -- TTP \u2264 10ms\n    ttb_threshold\u22cb(100)         -- TTB \u2264 100ms\n  )\n  \n  -- Verify contract\n  verify_rt_shield\u22cb(navigation_controller\u22cb, timing_contract\u22cb)\nend program"}
